Index: integration/ondemand/admin/dispatch/test_permissions.py
===================================================================
--- integration/ondemand/admin/dispatch/test_permissions.py	(revision 9d824a7731d3eecdbf398a03ca63953a0b5b1821)
+++ integration/ondemand/admin/dispatch/test_permissions.py	(revision 9d824a7731d3eecdbf398a03ca63953a0b5b1821)
@@ -1,51 +0,0 @@
-import pytest
-from pages.ondemand.admin.dispatch.dispatch import Dispatch
-from pytest import fixture
-
-
-@pytest.mark.ui
-class TestPermissions:
-    """Battery of tests for OnDemand Admin Dispatch page permissions."""
-
-    @pytest.fixture(autouse=True)
-    def set_pages(self, selenium: fixture) -> None:
-        """Instantiate all pages used in permissions testing.
-
-        :param selenium: An instance of Selenium web driver.
-        """
-        self.dispatch: Dispatch = Dispatch(selenium)
-
-    @pytest.mark.role_admin
-    def test_admin__dispatch_access(self) -> None:
-        """Check that Admin users may access the Dispatch page."""
-        self.dispatch.visit()
-
-        assert self.dispatch.loaded is True
-
-    @pytest.mark.role_agent
-    def test_agent__dispatch_access(self) -> None:
-        """Check that Agent users may access the Dispatch page."""
-        self.dispatch.visit()
-
-        assert self.dispatch.loaded is True
-
-    @pytest.mark.role_dispatcher
-    def test_dispatcher__dispatch_access(self) -> None:
-        """Check that Dispatcher users may access the Dispatch page."""
-        self.dispatch.visit()
-
-        assert self.dispatch.loaded is True
-
-    @pytest.mark.role_driver
-    def test_driver__dispatch_access(self) -> None:
-        """Check that Driver users may access the Dispatch page."""
-        self.dispatch.visit()
-
-        assert self.dispatch.loaded is True
-
-    @pytest.mark.role_rider
-    def test_rider__no_dispatch_access(self) -> None:
-        """Check that Rider users may not access the Dispatch page."""
-        self.dispatch.visit()
-
-        assert self.dispatch.loaded is False
Index: utilities/api_helpers/api.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\nimport os\nfrom random import random\nfrom time import sleep\nfrom typing import List\n\nimport requests\nfrom environs import Env\nfrom requests import Response\n\n\nsut_env = Env()\n\n\nclass API(object):\n    \"\"\"Base API class for use with API helper methods.\"\"\"\n\n    URL: str = None\n\n    @staticmethod\n    def build_api_url(path: str = '') -> str:\n        \"\"\"Construct an API URL from environment data.\n\n        :param path: Additional path for a site URL.\n        \"\"\"\n        env = sut_env.str('ENV')\n        port = sut_env.int('PORT')\n        team = sut_env.str('TEAM')\n\n        if env == 'localhost':\n            return f'http://{env}.transloc.com:{port}/v1{path}'\n        elif env == 'stage':\n            return f'https://api.stage.transloc.com/v1{path}'\n        else:\n            return f'https://api.{team}.{env}.transloc.com/v1{path}'\n\n    @staticmethod\n    def build_auth_headers() -> dict:\n        \"\"\"Consume the authenticate method to create an auth header for API usage.\"\"\"\n        _token: str = json.loads(os.getenv('AUTH_TOKEN'))['value']\n\n        return {'Authorization': f'Token {_token}', 'Content-Type': 'application/json'}\n\n    def create_request(self, data: dict, expected_response: List[int], url: str) -> dict:\n        \"\"\"Create an object using a specified API endpoint.\n\n        :param data: The intended data for creation.\n        :param expected_response: A list of expected responses.\n        :param url: The URL for creation.\n        \"\"\"\n        tries: int = 10\n\n        while True:\n            tries -= 1\n\n            sleep(random())\n            response: Response = requests.post(\n                url=url, headers=self.build_auth_headers(), data=json.dumps(data),\n            )\n\n            if response.status_code in expected_response:\n                return response.json()\n            elif tries == 0:\n                raise requests.HTTPError(f'Requests failed with response: {response.json()}')\n\n    def change_ride_status_request(\n        self, data: dict, expected_response: List[int], url: str,\n    ) -> None:\n        \"\"\"Change the status of a Ride or Recurring Ride object using a specified API endpoint.\n\n        :param data: The intended data for status change.\n        :param expected_response: A list of expected responses.\n        :param url: The URL for status change.\n        \"\"\"\n        tries: int = 10\n\n        while True:\n            tries -= 1\n\n            sleep(random())\n            response: Response = requests.patch(\n                url=url, headers=self.build_auth_headers(), data=json.dumps(data),\n            )\n            if response.status_code in expected_response:\n                break\n            elif tries == 0:\n                raise requests.HTTPError(f'Requests failed with response: {response.json()}')\n\n    def delete_request(self, expected_response: List[int], url: str) -> None:\n        \"\"\"Delete an object using a specified API endpoint.\n\n        :param expected_response: A list of expected responses.\n        :param url: The URL for deletion.\n        \"\"\"\n        tries: int = 10\n\n        while True:\n            tries -= 1\n\n            sleep(random())\n            response: Response = requests.delete(\n                url=url, headers=self.build_auth_headers(),\n            )\n\n            if response.status_code in expected_response:\n                break\n            elif tries == 0:\n                raise requests.HTTPError(f'Requests failed with response: {response.json()}')\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- utilities/api_helpers/api.py	(revision 9d824a7731d3eecdbf398a03ca63953a0b5b1821)
+++ utilities/api_helpers/api.py	(date 1595004676405)
@@ -2,11 +2,12 @@
 import os
 from random import random
 from time import sleep
-from typing import List
+from typing import List, Union
 
 import requests
 from environs import Env
-from requests import Response
+from requests import HTTPError, Response
+from utilities.constants.common import API_PASSWORD, USERNAME
 
 
 sut_env = Env()
@@ -17,6 +18,26 @@
 
     URL: str = None
 
+    @staticmethod
+    def authenticate(username: str) -> Union[dict, None]:
+        """Authenticate using the API for framework login.
+
+        :param username: The username for application login.
+        """
+        _url: str = API.build_api_url(f'/me/login?username={username}&password={API_PASSWORD}')
+        tries: int = 10
+
+        while True:
+            tries -= 1
+
+            sleep(random())
+            response: Response = requests.post(url=_url)
+
+            if response.status_code == 200:
+                return response.json()
+            elif tries == 0:
+                raise HTTPError(f'Requests failed with response: {response.json()}')
+
     @staticmethod
     def build_api_url(path: str = '') -> str:
         """Construct an API URL from environment data.
@@ -34,19 +55,40 @@
         else:
             return f'https://api.{team}.{env}.transloc.com/v1{path}'
 
-    @staticmethod
-    def build_auth_headers() -> dict:
+    def build_auth_headers(self) -> dict:
         """Consume the authenticate method to create an auth header for API usage."""
+        # self.capture_token(USERNAME)
         _token: str = json.loads(os.getenv('AUTH_TOKEN'))['value']
 
         return {'Authorization': f'Token {_token}', 'Content-Type': 'application/json'}
 
-    def create_request(self, data: dict, expected_response: List[int], url: str) -> dict:
-        """Create an object using a specified API endpoint.
+    def capture_token(self, username: str) -> None:
+        """Capture an authentication token as an environment variable for framework usage.
+
+        :param username: The username for application login.
+        """
+        _auth_response: dict = self.authenticate(username)
+        _token: str = _auth_response['token']
+        _cookie: dict = dict(
+            domain='.transloc.com',
+            httpOnly=False,
+            name='transloc_authn_cookie',
+            path='/',
+            secure=False,
+            value=f'{_token}',
+        )
+        json_cookie = json.dumps(_cookie)
 
-        :param data: The intended data for creation.
+        os.environ['AUTH_TOKEN'] = json_cookie
+
+    def change_ride_status_request(
+        self, data: dict, expected_response: List[int], url: str,
+    ) -> None:
+        """Change the status of a Ride or Recurring Ride object using a specified API endpoint.
+
+        :param data: The intended data for status change.
         :param expected_response: A list of expected responses.
-        :param url: The URL for creation.
+        :param url: The URL for status change.
         """
         tries: int = 10
 
@@ -54,23 +96,20 @@
             tries -= 1
 
             sleep(random())
-            response: Response = requests.post(
+            response: Response = requests.patch(
                 url=url, headers=self.build_auth_headers(), data=json.dumps(data),
             )
-
             if response.status_code in expected_response:
-                return response.json()
+                break
             elif tries == 0:
                 raise requests.HTTPError(f'Requests failed with response: {response.json()}')
 
-    def change_ride_status_request(
-        self, data: dict, expected_response: List[int], url: str,
-    ) -> None:
-        """Change the status of a Ride or Recurring Ride object using a specified API endpoint.
+    def create_request(self, data: dict, expected_response: List[int], url: str) -> dict:
+        """Create an object using a specified API endpoint.
 
-        :param data: The intended data for status change.
+        :param data: The intended data for creation.
         :param expected_response: A list of expected responses.
-        :param url: The URL for status change.
+        :param url: The URL for creation.
         """
         tries: int = 10
 
@@ -78,11 +117,12 @@
             tries -= 1
 
             sleep(random())
-            response: Response = requests.patch(
+            response: Response = requests.post(
                 url=url, headers=self.build_auth_headers(), data=json.dumps(data),
             )
+
             if response.status_code in expected_response:
-                break
+                return response.json()
             elif tries == 0:
                 raise requests.HTTPError(f'Requests failed with response: {response.json()}')
 
Index: utilities/api_helpers/authentication.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import json\nimport os\nfrom random import random\nfrom time import sleep\nfrom typing import Union\n\nimport requests\nfrom requests import HTTPError, Response\nfrom utilities.api_helpers.api import API\nfrom utilities.constants.common import API_PASSWORD\n\n\nclass Authentication(API):\n    \"\"\"API methods for application authentication.\"\"\"\n\n    @staticmethod\n    def authenticate(username: str) -> Union[dict, None]:\n        \"\"\"Authenticate using the API for framework login.\n\n        :param username: The username for application login.\n        \"\"\"\n        _url: str = API.build_api_url(f'/me/login?username={username}&password={API_PASSWORD}')\n        tries: int = 10\n\n        while True:\n            tries -= 1\n\n            sleep(random())\n            response: Response = requests.post(url=_url)\n\n            if response.status_code == 200:\n                return response.json()\n            elif tries == 0:\n                raise HTTPError(f'Requests failed with response: {response.json()}')\n\n    def capture_token(self, username: str) -> None:\n        \"\"\"Capture an authentication token as an environment variable for framework usage.\n\n        :param username: The username for application login.\n        \"\"\"\n        _auth_response: dict = self.authenticate(username)\n        _token: str = _auth_response['token']\n        _cookie: dict = dict(\n            domain='.transloc.com',\n            httpOnly=False,\n            name='transloc_authn_cookie',\n            path='/',\n            secure=False,\n            value=f'{_token}',\n        )\n        json_cookie = json.dumps(_cookie)\n\n        os.environ['AUTH_TOKEN'] = json_cookie\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- utilities/api_helpers/authentication.py	(revision 9d824a7731d3eecdbf398a03ca63953a0b5b1821)
+++ utilities/api_helpers/authentication.py	(date 1595004573136)
@@ -7,7 +7,7 @@
 import requests
 from requests import HTTPError, Response
 from utilities.api_helpers.api import API
-from utilities.constants.common import API_PASSWORD
+from utilities.constants.common import API_PASSWORD, USERNAME
 
 
 class Authentication(API):
@@ -33,6 +33,13 @@
             elif tries == 0:
                 raise HTTPError(f'Requests failed with response: {response.json()}')
 
+    def build_auth_headers(self) -> dict:
+        """Consume the authenticate method to create an auth header for API usage."""
+        self.capture_token(USERNAME)
+        _token: str = json.loads(os.getenv('AUTH_TOKEN'))['value']
+
+        return {'Authorization': f'Token {_token}', 'Content-Type': 'application/json'}
+
     def capture_token(self, username: str) -> None:
         """Capture an authentication token as an environment variable for framework usage.
 
Index: conftest.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from typing import Generator, List\n\nimport pytest\nfrom environs import Env\nfrom faker import Faker\nfrom marshmallow.validate import OneOf\nfrom pages import Login\nfrom pytest import fixture\nfrom selenium.webdriver.chrome.options import Options\nfrom selenium.webdriver.chrome.webdriver import WebDriver\nfrom utilities.api_helpers.authentication import Authentication\nfrom utilities.constants.common import USERNAME, USERS\nfrom utilities.exceptions import ConfigurationException\n\n\nsut_env = Env()\nfake = Faker('en_US')\n\nAGENCY: str = sut_env.str('AGENCY', default='imperialdemo')\nENV: str = sut_env.str(\n    'ENV',\n    default='dev',\n    validate=OneOf(\n        ['dev', 'localhost', 'stage'],\n        error='ENV must be one of the following: {choices}. Please enter a valid choice.',\n    ),\n)\nHEADLESS: bool = sut_env.bool('HEADLESS', default=True)\nPORT: int = sut_env.int('PORT', default=8080)\nTEAM: str = sut_env.str(\n    'TEAM',\n    default='mamlambo',\n    validate=OneOf(\n        ['bloop', 'kraken', 'mamlambo', 'thunderbird'],\n        error='TEAM must be one of the following: {choices}. Please enter a valid choice.',\n    ),\n)\n\n\ndef build_site_url(app: str, path: str = '') -> str:\n    \"\"\"Construct an application specific URL based on environment data.\n\n    :param app: The application under test.\n    :param path: Additional path for a site URL.\n    \"\"\"\n    validate_application(app)\n\n    if ENV == 'localhost':\n        return f'http://{ENV}.transloc.com:{PORT}{path}'\n    elif ENV == 'stage':\n        return f'https://{app}.{ENV}.transloc.com{path}'\n    else:\n        return f'https://{app}.{TEAM}.{ENV}.transloc.com{path}'\n\n\n@pytest.fixture\ndef chrome_options(chrome_options: Options) -> Options:\n    \"\"\"Construct and return chrome options to an instance of Google Chrome.\n\n    By default, headed testing is disabled. For headed testing, add 'HEADLESS=False' as an\n    environment variable.\n\n    :param chrome_options: Options being distributed to Chrome.\n    \"\"\"\n    chrome_options.add_argument('--no-sandbox')\n    chrome_options.add_argument('--disable-extensions')\n    chrome_options.add_argument('--disable-notifications')\n    chrome_options.add_argument('--window-size=1680x1050')\n\n    chrome_options.headless = False if sut_env.bool('HEADLESS') is False else True\n    return chrome_options\n\n\n@pytest.fixture(autouse=True)\ndef login(request: fixture, selenium: fixture) -> None:\n    \"\"\"Login via submitting a login form or auth token.\n\n    Runs a check to determine if an auth token exists. If one exists, the framework will add the\n    auth token as a cookie. If not, the framework will input valid login credentials, then capture\n    the auth token for later tests.\n\n    :param request: Fixture for requesting Pytest configuration data.\n    :param selenium: An instance of Selenium Web Driver.\n    \"\"\"\n    login_api = Authentication()\n    login_page = Login(selenium)\n\n    if 'no_auth' not in request.keywords:\n\n        #\n        # Check for specific pytest marks for permissions, then login accordingly\n        #\n        if 'role_admin' in request.keywords:\n            login_api.capture_token(USERS.Admin.USERNAME)\n        elif 'role_agent' in request.keywords:\n            login_api.capture_token(USERS.Agent.USERNAME)\n        elif 'role_driver' in request.keywords:\n            login_api.capture_token(USERS.Driver.USERNAME)\n        elif 'role_dispatcher' in request.keywords:\n            login_api.capture_token(USERS.Dispatcher.USERNAME)\n        elif 'role_rider' in request.keywords:\n            login_api.capture_token(USERS.Rider.USERNAME)\n        else:\n            login_api.capture_token(USERNAME)\n\n    login_page.visit()\n    login_page.add_auth_token()\n\n\n@pytest.fixture\ndef selenium(selenium: fixture) -> WebDriver:\n    \"\"\"Override the base Selenium settings.\n\n    :param selenium: Fixture for running an instantiation of Selenium webdriver.\n    \"\"\"\n    selenium.maximize_window()\n    return selenium\n\n\n@pytest.fixture(scope='session', autouse=True)\ndef system_under_test() -> Generator:\n    \"\"\"Create system under test prior to test instantiation.\"\"\"\n    sut_env.read_env()\n\n    yield\n\n\ndef validate_application(app: str) -> None:\n    \"\"\"Check whether an application is supported or not.\n\n    :param app: The specified application.\n    \"\"\"\n    supported_applications: List[str] = ['architect', 'ondemand', 'realtime', 'traveler']\n\n    if app not in supported_applications:\n        raise ConfigurationException(\n            f'The application: \"{app}\" is not supported.\\nPlease specify a valid application.',\n        )\n    elif app is None:\n        raise ConfigurationException('Please specify an application.')\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- conftest.py	(revision 9d824a7731d3eecdbf398a03ca63953a0b5b1821)
+++ conftest.py	(date 1595004573146)
@@ -8,7 +8,7 @@
 from pytest import fixture
 from selenium.webdriver.chrome.options import Options
 from selenium.webdriver.chrome.webdriver import WebDriver
-from utilities.api_helpers.authentication import Authentication
+from utilities.api_helpers.api import API
 from utilities.constants.common import USERNAME, USERS
 from utilities.exceptions import ConfigurationException
 
@@ -82,7 +82,7 @@
     :param request: Fixture for requesting Pytest configuration data.
     :param selenium: An instance of Selenium Web Driver.
     """
-    login_api = Authentication()
+    login_api = API()
     login_page = Login(selenium)
 
     if 'no_auth' not in request.keywords:
@@ -113,6 +113,7 @@
 
     :param selenium: Fixture for running an instantiation of Selenium webdriver.
     """
+    selenium.delete_all_cookies()
     selenium.maximize_window()
     return selenium
 
